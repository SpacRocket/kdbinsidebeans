{
//  generate = [token-accessors="yes"]

  parserClass="org.kdb.inside.brains.parser.QParser"

  extends="org.kdb.inside.brains.psi.impl.QPsiElementImpl"
  implements="org.kdb.inside.brains.psi.QPsiElement"

  psiClassPrefix="Q"
  psiImplClassSuffix="Impl"
  psiPackage="org.kdb.inside.brains.psi"
  psiImplPackage="org.kdb.inside.brains.psi.impl"

  tokenTypeClass="org.kdb.inside.brains.psi.QTokenType"
  elementTypeClass="org.kdb.inside.brains.psi.QElementType"
  elementTypeHolderClass="org.kdb.inside.brains.psi.QTypes"

  rightAssociative=true

  extends(".*expr|var_reference")=expression
  consumeTokenMethod="consumeTokenFast"

  tokens=[
    NILL="(::)"
    COLON=':'
    SEMICOLON=';'
    BRACKET_OPEN='['
    BRACKET_CLOSE=']'
    BRACE_OPEN='{'
    BRACE_CLOSE='}'
    PAREN_OPEN='('
    PAREN_CLOSE=')'

    NEW_LINE="new line"

    COMMAND_IMPORT="import command"
    COMMAND_CONTEXT="context command"
    COMMAND_SYSTEM="system command"
    COMMAND_ARGUMENTS="command arguments"

    FUNCTION_IMPORT="import function"

    TYPE_CAST_PATTERN="type cast pattern"

    ITERATOR="iterator"
    ACCUMULATOR="accumulator"

    OPERATOR_ORDER="operator order"
    OPERATOR_EQUALITY="operator equality"
    OPERATOR_ARITHMETIC="operator arithmetic"
    OPERATOR_WEIGHT="operator weight"
    OPERATOR_COMMA="operator comma"
    OPERATOR_OTHERS="operator others"

    MODE_PATTERN="mode"
    SYMBOL_PATTERN="symbol"
    VARIABLE_PATTERN="variable"
    FILE_PATH_PATTERN="string path"
    SYMBOL_PATH_PATTERN="symbol path"

    UNARY_FUNCTION="unary function"
    BINARY_FUNCTION="binary function"
    COMPLEX_FUNCTION="complex function"

    QUERY_BY="query by"
    QUERY_TYPE="query type"
    QUERY_FROM="query from"
    QUERY_SPLITTER="query comma"

    VECTOR="vector"

    SIGNED_ATOM="signed atom"
    UNSIGNED_ATOM="unsigned atom"

    CHAR="char"
    STRING="string"

    CONTROL_KEYWORD="control"
    CONDITION_KEYWORD="condition"

    LINE_COMMENT='line comment'
    BLOCK_COMMENT='block comment'
  ]
}

root ::= top*
line_break ::= NEW_LINE

private top ::= context | mode | top_in_context
private top_in_context ::= import_command | command | expression | separator

private end_of_line_recover ::= !(line_break)

private separator ::= SEMICOLON | line_break

private statement ::= SEMICOLON | expression SEMICOLON?

// Context: \d ...
context_body ::= top_in_context*
context ::= COMMAND_CONTEXT var_declaration? (line_break context_body)? {
 pin(".*") = 1
 mixin = "org.kdb.inside.brains.psi.impl.QPsiContextImpl"
 methods = [variable="var_declaration"]
 }

// command - anything with \...
command ::= COMMAND_SYSTEM  command_params? { pin = 1 methods = [command="COMMAND_SYSTEM" parameters="COMMAND_ARGUMENTS"] }
private command_params ::= COMMAND_ARGUMENTS {recoverWhile = end_of_line_recover}

import_command ::= COMMAND_IMPORT import_command_file { pin = 1 implements="org.kdb.inside.brains.psi.QImport" }
private import_command_file ::= FILE_PATH_PATTERN {recoverWhile = end_of_line_recover }

import_function ::= FUNCTION_IMPORT expression { pin = 1 extends=expression implements="org.kdb.inside.brains.psi.QImport" }

// In mode we can't use line_break as a separator
private mode_content ::= statement+ { recoverWhile = end_of_line_recover }
mode ::= MODE_PATTERN mode_content? { pin = 1 methods=[modeName="MODE_PATTERN"] } // Mode: [a-Z]) .....

// ============ Custom types ====================
symbol ::= SYMBOL_PATTERN

var_reference ::= VARIABLE_PATTERN {
 implements="org.kdb.inside.brains.psi.QVariable"
 mixin="org.kdb.inside.brains.psi.impl.QVariableReferenceImpl"
}

var_declaration ::= VARIABLE_PATTERN {
 implements=["org.kdb.inside.brains.psi.QVariable" "com.intellij.psi.PsiNameIdentifierOwner" "com.intellij.psi.NavigatablePsiElement"]
 mixin="org.kdb.inside.brains.psi.impl.QVariableDeclarationImpl"
}

iterator_type ::= ACCUMULATOR? ITERATOR+
operator_type ::= OPERATOR_ORDER | OPERATOR_EQUALITY | OPERATOR_ARITHMETIC | OPERATOR_WEIGHT | OPERATOR_OTHERS | OPERATOR_COMMA

console_handler ::= "0" | "1" | "2" | "-1" | "-2"
system_function ::= UNARY_FUNCTION | BINARY_FUNCTION | COMPLEX_FUNCTION

arguments ::= BRACKET_OPEN [!BRACKET_CLOSE statement*] BRACKET_CLOSE {pin(".*")=1}
private arguments_list ::= arguments+

var_indexing ::= var_reference arguments_list {pin=2 methods=[variable="var_reference" arguments="arguments"]}

fake assignment_type ::= COLON {}
var_assignment_type ::= operator_type COLON | COLON COLON? { extends=assignment_type elementType=assignment_type }
column_assignment_type ::= COLON { extends=assignment_type elementType=assignment_type }

private index_assignment ::= var_indexing var_assignment_type expression { pin = 2 }
private variable_assignment ::= var_declaration var_assignment_type operator_type? expression { pin = 2 }
assignment_expr ::= index_assignment | variable_assignment

control_expr ::= CONTROL_KEYWORD arguments { pin = 1 } // if/else/while and so on
condition_expr ::= CONDITION_KEYWORD arguments { pin=1 } // $[...]

expressions ::= separator* expression (separator+ expression)* separator*

return_expr ::= COLON expression

signal_expr ::= "'" expression

literal_expr ::= NILL | CHAR | SIGNED_ATOM | UNSIGNED_ATOM | VECTOR | STRING | symbol symbol*

parameters ::= BRACKET_OPEN [parameters_body] BRACKET_CLOSE { pin(".*")=1 methods = [variables="var_declaration"] }
private parameters_body ::= var_declaration (SEMICOLON var_declaration)* {pin(".*")="SEMICOLON" recoverWhile=parameters_recover }
private parameters_recover ::= !(BRACKET_OPEN | BRACKET_CLOSE)

lambda_expr ::= BRACE_OPEN lambda_body BRACE_CLOSE {pin=1}
private lambda_body ::= parameters? expressions? {recoverWhile=lambda_recover}
private lambda_recover ::= !(BRACE_OPEN | BRACE_CLOSE)

operation ::= (iterator_type | operator_type)+

fake invoke_object ::= operator_type? invoke_function_group?
invoke_operator ::= operator_type {extends=invoke_object}

invoke_function ::= invoke_function_group {extends=invoke_object}
private invoke_function_group ::= BINARY_FUNCTION | COMPLEX_FUNCTION | UNARY_FUNCTION | console_handler | prefix_expr

parentheses_expr ::= PAREN_OPEN !BRACKET_OPEN parentheses_body PAREN_CLOSE {pin=2 extends=invoke_object}
private parentheses_body ::= SEMICOLON* (expression SEMICOLON+)* expression? {pin(".*")=2 recoverWhile=parentheses_recover}
private parentheses_recover ::= !(PAREN_OPEN | PAREN_CLOSE)

fake invoke_expr ::= (invoke_operator | invoke_function | parentheses_expr) arguments_list? operation? expression?
prefix_invoke_expr ::= invoke_operator arguments_list operation? expression? { pin=2 extends=invoke_expr}
function_invoke_expr ::= invoke_function ((arguments_list? ((operation? expression) | operation)) | (arguments_list operation?)) { extends=invoke_expr }
parentheses_invoke_expr ::= parentheses_expr arguments_list? operation? expression? { extends=invoke_expr }

private invoke_group ::= parentheses_invoke_expr | prefix_invoke_expr | function_invoke_expr

type_cast_expr ::= TYPE_CAST_PATTERN expression? {pin = 1 methods=[typeCast="TYPE_CAST_PATTERN"]}

// extends doesn't work in this case - have to do implements and redefine the method for each
table_column ::= (var_declaration column_assignment_type expression) | expression {pin(".*")=2}
private table_columns_group ::= table_column (SEMICOLON table_column)* {pin(".*")="SEMICOLON"}
fake table_columns ::= table_columns_group {methods=[columns="table_column"]}
table_keys ::= table_columns_group {implements=table_columns methods=[columns="table_column"] recoverWhile=table_keys_recover}
private table_keys_recover ::= !BRACKET_CLOSE
table_values ::= table_columns_group {implements=table_columns methods=[columns="table_column"] recoverWhile=table_values_recover}
private table_values_recover ::= !PAREN_CLOSE
table_expr ::= PAREN_OPEN BRACKET_OPEN [table_keys] BRACKET_CLOSE [SEMICOLON? table_values] PAREN_CLOSE { pin=2 methods=[keys="table_keys" values="table_values"]}

// But extends works here with no issues
query_column ::= (var_declaration column_assignment_type expression) | expression {pin(".*")=2}
private query_columns_group ::= query_column (QUERY_SPLITTER query_column)* {pin(".*")="QUERY_SPLITTER"}
fake query_columns ::= query_columns_group {methods=[columns="query_column"]}
query_keys ::= query_columns_group {extends=query_columns}
query_values ::= query_columns_group {extends=query_columns}

private query_body ::= QUERY_TYPE [query_values] (QUERY_BY query_keys)? { pin=1 methods=[QUERY_TYPE="QUERY_TYPE" keys="query_keys" values="query_values"] recoverWhile=query_body_recover}
private query_body_recover ::= !QUERY_FROM
private query_source ::= QUERY_FROM expression {pin=1}
query_expr ::= query_body query_source

grouping_expr ::= BRACKET_OPEN expressions BRACKET_CLOSE

k_syntax_expr ::= operation+ expression

projection_expr ::= (operator_type | iterator_type | OPERATOR_ARITHMETIC | SYMBOL_PATH_PATTERN | COLON | OPERATOR_COMMA | literal_expr)+ | system_function | FUNCTION_IMPORT

// Only these expressions can be used as a left arguments of invokes
prefix_expr ::=
    table_expr
    | literal_expr
    | lambda_expr
    | control_expr
    | condition_expr
    | grouping_expr
    | var_reference
    { elementType=expression}

expression ::= assignment_expr
    | type_cast_expr
    | query_expr
    | import_function
    | invoke_group
    | prefix_expr
    | return_expr
    | signal_expr
    | k_syntax_expr
    | projection_expr
    { extraRoot=true }