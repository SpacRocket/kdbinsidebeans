{
  parserClass="org.kdb.inside.brains.parser.QParser"

  extends="org.kdb.inside.brains.psi.impl.QPsiElementImpl"
  implements="org.kdb.inside.brains.psi.QPsiElement"

  psiClassPrefix="Q"
  psiImplClassSuffix="Impl"
  psiPackage="org.kdb.inside.brains.psi"
  psiImplPackage="org.kdb.inside.brains.psi.impl"

  tokenTypeClass="org.kdb.inside.brains.psi.QTokenType"
  elementTypeClass="org.kdb.inside.brains.psi.QElementType"
  elementTypeHolderClass="org.kdb.inside.brains.psi.QTypes"

  tokens=[
    nill="(::)"
    colon=':'
    comma=',' // Double meaning here - splitting arguments in a table or an operator
    semicolon=';'
    bracket_open='['
    bracket_close=']'
    brace_open='{'
    brace_close='}'
    paren_open='('
    paren_close=')'

    line_break="Line break"
    line_space="Line space"

    command_import="import file command"
    command_context="changing context command"
    command_system="internal or external system command"
    command_arguments="internal or external command arguments"

    type_cast_pattern="type cast pattern"

    operator="operator"
    iterator="iterator"

    mode_pattern="mode name"
    symbol_pattern="symbol pattern"
    variable_pattern="Variable is"
    file_path_pattern="File path is"

    unary_function="unary function"
    binary_function="binary function"
    complex_function="complex function"

    query_by="query by"
    query_type="query type"
    query_from="query from"

    atom="atom"
    vector="vector"

    char="char"
    string="string"

    control_pattern="control"
    condition_pattern="conditional"

    line_comment='line comment'
    block_comment='block comment'
  ]
}

root ::= top*

private separator ::= semicolon | line_break
private end_of_line ::= !(line_break)

private top ::= import | context | command | mode | expression_common | separator

symbol ::= symbol_pattern {
  implements="org.kdb.inside.brains.psi.QSymbolElement"
  mixin="org.kdb.inside.brains.psi.impl.QSymbolElementImpl"
}
private symbols ::= symbol symbol+

variable ::= variable_pattern {
  implements="org.kdb.inside.brains.psi.QVariableElement"
  mixin="org.kdb.inside.brains.psi.impl.QVariableElementImpl"
}

// Import supporting
import_file ::= file_path_pattern { recoverWhile = end_of_line }
import ::= command_import line_space import_file {
    pin = 1
    implements="org.kdb.inside.brains.psi.QImportElement"
    mixin="org.kdb.inside.brains.psi.impl.QImportElementImpl"
    }

fake assignment ::= variable? arguments? expression_common?
fake column_assignment ::= variable? expression_common? {
 extends = assignment
}

variable_assignment ::= variable [arguments] (operator colon | colon colon | colon) expression_common {
 pin = 3
 extends = assignment
}

inner table_column ::= (variable colon expression_common) | expression_common  {
 pin(".*") = 2
 extends = column_assignment
 }
private table_cols ::= table_column (semicolon table_column)*
fake table_columns ::= table_cols {
 methods = [columns="table_column"]
}
inner key_columns ::= table_cols {
 implements="table_columns"
 methods = [columns="table_column"]
}
inner value_columns ::= table_cols {
 implements="table_columns"
 methods = [columns="table_column"]
}
table ::= paren_open bracket_open [key_columns] bracket_close [value_columns] paren_close {
 pin = 2
}

inner query_column ::= (variable colon expression_query) | expression_query  {
 pin(".*") = 2
 extends = column_assignment
}
private query_cols ::= query_column (comma query_column)*
fake query_columns ::= query_cols
query_groups ::= query_cols {
 implements="query_columns"
}
query_selects ::= query_cols {
 implements="query_columns"
}
// - not mistake. WHERE goes into the final expression here and belong to it by Q grammar
// - we do where fist and then select from the result what we need.
query ::= query_type [query_selects] (query_by query_groups)? (query_from expression_common) {
 pin(".*")=1
 methods = [columns="query_selects" groups="query_groups"]
 }

// Context: \d ...
private context_name ::= variable {recoverWhile = end_of_line }
context ::= command_context (line_space+ context_name expressions)? {
 pin = 1
 mixin = "org.kdb.inside.brains.psi.impl.QContextElementImpl"
 }

// Command - anything with \...
private command_params ::= command_arguments {recoverWhile = end_of_line}
command ::= command_system (line_space+ command_params)? { pin = 1}

// In mode we can't use line_break as a separator
private mode_content ::= semicolon* expression_common (semicolon+ expression_common)* semicolon* {
 recoverWhile = end_of_line
}
mode ::= mode_pattern [mode_content] { pin = 1 } // Mode: [a-Z]) .....

parameters ::= bracket_open [variable (semicolon variable)*] bracket_close // it's not private for fast search
lambda ::= brace_open [parameters] [expressions] brace_close {pin = 1}

arguments ::= bracket_open [expressions] bracket_close {pin = 1}// [...]

control ::= control_pattern arguments // if/else/while and so on
condition ::= condition_pattern arguments // $[...]

//  `$ or `...$ - it's a type cast, not a symbol
type_cast ::= type_cast_pattern

//dict ::= key_statement "!" expression { pin = 2}
list ::= vector | symbols | string | mix_list
private mix_list ::= paren_open [expression_common] (semicolon+ [expression_common])+ semicolon* paren_close { pin=3 }

parentheses ::= paren_open expression_common paren_close

private unary_invokable ::= unary_function | lambda | variable | list | parentheses
private binary_invokable ::= binary_function | complex_function | ((operator | iterator) colon?)
invoke ::= (unary_invokable | binary_invokable) iterator? arguments+

private function ::= unary_function | binary_function | complex_function | lambda
private statement ::= control | condition | type_cast | variable_assignment | invoke | variable | table | list | parentheses | nill | atom | symbol | char | arguments | function | operator | iterator | colon colon?

fake expression ::= query | (statement | comma)+ query?
expression_query ::= statement+ {
 extends = expression
}
expression_common ::= query | (statement | comma)+ query? {
 extends = expression
}

private expressions ::= separator* expression_common (separator+ expression_common)* separator*