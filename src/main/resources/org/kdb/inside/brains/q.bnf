{
//  generate = [token-accessors="yes"]

  parserClass="org.kdb.inside.brains.parser.QParser"

  extends="org.kdb.inside.brains.psi.impl.QPsiElementImpl"
  implements="org.kdb.inside.brains.psi.QPsiElement"

  psiClassPrefix="Q"
  psiImplClassSuffix="Impl"
  psiPackage="org.kdb.inside.brains.psi"
  psiImplPackage="org.kdb.inside.brains.psi.impl"

  tokenTypeClass="org.kdb.inside.brains.psi.QTokenType"
  elementTypeClass="org.kdb.inside.brains.psi.QElementType"
  elementTypeHolderClass="org.kdb.inside.brains.psi.QTypes"

  rightAssociative=true

  extends(".*expr|var_reference")=expression
  consumeTokenMethod="consumeTokenFast"

  tokens=[
    NILL="(::)"
    COLON=':'
    SEMICOLON=';'
    BRACKET_OPEN='['
    BRACKET_CLOSE=']'
    BRACE_OPEN='{'
    BRACE_CLOSE='}'
    PAREN_OPEN='('
    PAREN_CLOSE=')'

    LINE_BREAK="break"
    LINE_SPACE="space"

    COMMAND_IMPORT="import command"
    COMMAND_CONTEXT="context command"
    COMMAND_SYSTEM="system command"
    COMMAND_ARGUMENTS="command arguments"

    FUNCTION_IMPORT="import function"

    TYPE_CAST_PATTERN="type cast pattern"

    ITERATOR="iterator"
    ACCUMULATOR="accumulator"

    OPERATOR_ORDER="operator order"
    OPERATOR_EQUALITY="operator equality"
    OPERATOR_ARITHMETIC="operator arithmetic"
    OPERATOR_WEIGHT="operator weight"
    OPERATOR_COMMA="operator comma"
    OPERATOR_OTHERS="operator others"

    MODE_PATTERN="mode"
    SYMBOL_PATTERN="symbol"
    VARIABLE_PATTERN="variable"
    FILE_PATH_PATTERN="string path"
    SYMBOL_PATH_PATTERN="symbol path"

    UNARY_FUNCTION="unary function"
    BINARY_FUNCTION="binary function"
    COMPLEX_FUNCTION="complex function"

    QUERY_BY="query by"
    QUERY_TYPE="query type"
    QUERY_FROM="query from"
    QUERY_SPLITTER="query comma"

    VECTOR="vector"

    SIGNED_ATOM="signed atom"
    UNSIGNED_ATOM="unsigned atom"

    CHAR="char"
    STRING="string"

    CONTROL_KEYWORD="control"
    CONDITION_KEYWORD="condition"

    LINE_COMMENT='line comment'
    BLOCK_COMMENT='block comment'
  ]
}

root ::= top*
//private top ::= expression | separator
private top ::= context | mode | top_in_context
private top_in_context ::= import_command | command | expression | separator


private separator ::= SEMICOLON | LINE_BREAK
private end_of_line_recover ::= !(LINE_BREAK)

private statement ::= SEMICOLON | expression SEMICOLON?

// Context: \d ...
context_body ::= top_in_context*
context ::= COMMAND_CONTEXT var_declaration? (LINE_BREAK context_body)? {
 pin(".*") = 1
 mixin = "org.kdb.inside.brains.psi.impl.QPsiContextImpl"
 methods = [variable="var_declaration"]
 }

/*
command_params ::= command_arguments {recoverWhile = end_of_line}
command ::= command_system (line_space+ command_params)? {
 pin = 1
 methods = [parameters="command_params"]--

}

*/
// command - anything with \...
private command_params ::= COMMAND_ARGUMENTS {recoverWhile = end_of_line_recover}
command ::= COMMAND_SYSTEM  (LINE_SPACE+ command_params)? { pin = 1 methods = [command="COMMAND_SYSTEM" parameters="COMMAND_ARGUMENTS"] }
/*

command ::= COMMAND_SYSTEM (LINE_SPACE+ COMMAND_ARGUMENTS)? { pin = 1 methods=[commandName="COMMAND_SYSTEM" commandParameters="COMMAND_ARGUMENTS"] recoverWhile=end_of_line_recover}
*/

import_file ::= FILE_PATH_PATTERN { recoverWhile = end_of_line_recover }
import_command ::= COMMAND_IMPORT import_file {
 pin = 1
 implements="org.kdb.inside.brains.psi.QImport"
 mixin="org.kdb.inside.brains.psi.impl.QImportCommandBase"
 }

import_expr ::= FUNCTION_IMPORT STRING {
 pin = 1
 implements="org.kdb.inside.brains.psi.QImport"
 mixin="org.kdb.inside.brains.psi.impl.QImportFunctionBase"
 }

// In mode we can't use LINE_BREAK as a separator
private mode_content ::= statement+ { recoverWhile = end_of_line_recover }
mode ::= MODE_PATTERN mode_content? { pin = 1 methods=[modeName="MODE_PATTERN"] } // Mode: [a-Z]) .....

// ============ Custom types ====================
symbol ::= SYMBOL_PATTERN

var_reference ::= VARIABLE_PATTERN {
 implements="org.kdb.inside.brains.psi.QVariable"
 mixin="org.kdb.inside.brains.psi.impl.QVariableReferenceImpl"
}

var_declaration ::= VARIABLE_PATTERN {
 implements=["org.kdb.inside.brains.psi.QVariable" "com.intellij.psi.PsiNameIdentifierOwner" "com.intellij.psi.NavigatablePsiElement"]
 mixin="org.kdb.inside.brains.psi.impl.QVariableDeclarationImpl"
}

iterator_type ::= ACCUMULATOR? ITERATOR+
//operator_type ::= OPERATOR_ORDER | OPERATOR_EQUALITY | OPERATOR_WEIGHT | OPERATOR_OTHERS | OPERATOR_COMMA
operator_type ::= OPERATOR_ORDER | OPERATOR_EQUALITY | OPERATOR_ARITHMETIC | OPERATOR_WEIGHT | OPERATOR_OTHERS | OPERATOR_COMMA

console_handler ::= "0" | "1" | "2" | "-1" | "-2"
system_function ::= UNARY_FUNCTION | BINARY_FUNCTION | COMPLEX_FUNCTION

arguments ::= BRACKET_OPEN [!BRACKET_CLOSE statement*] BRACKET_CLOSE {pin(".*")=1}
private arguments_list ::= arguments+

var_indexing ::= var_reference arguments_list {pin=2 methods=[variable="var_reference" arguments="arguments"]}

fake assignment_type ::= COLON {}
var_assignment_type ::= operator_type COLON | COLON COLON? { extends=assignment_type elementType=assignment_type }
column_assignment_type ::= COLON { extends=assignment_type elementType=assignment_type }

private index_assignment ::= var_indexing var_assignment_type expression { pin = 2 }
private variable_assignment ::= var_declaration var_assignment_type operator_type? expression { pin = 2 }
assignment_expr ::= index_assignment | variable_assignment

control_expr ::= CONTROL_KEYWORD arguments { pin = 1 } // if/else/while and so on
condition_expr ::= CONDITION_KEYWORD arguments { pin=1 } // $[...]

expressions ::= separator* expression (separator+ expression)* separator*
//private statement_group ::= separator* expression (separator+ expression)* separator*
//statement ::= statement_group | BRACKET_OPEN [!BRACKET_CLOSE statement_group] BRACKET_CLOSE

private vector_atom ::= VECTOR | STRING | symbol symbol+
private vector_mixed ::= PAREN_OPEN [!PAREN_CLOSE] expression? SEMICOLON+ (expression SEMICOLON+)* expression? PAREN_CLOSE { pin(".*") = 4 }
//private vector_mixed ::= PAREN_OPEN [expression] (SEMICOLON+ [expression])+ SEMICOLON* PAREN_CLOSE { pin(".*") = 3 }
vector_expr ::= vector_atom | vector_mixed

return_expr ::= COLON expression

signal_expr ::= "'" expression

literal_expr ::= NILL | symbol | CHAR | SIGNED_ATOM | UNSIGNED_ATOM

parentheses_expr ::= PAREN_OPEN expression PAREN_CLOSE

parameters ::= BRACKET_OPEN [ !BRACKET_CLOSE var_declaration (SEMICOLON var_declaration)* ] BRACKET_CLOSE { pin(".*")=1 methods = [variables="var_declaration"] }
/*
parameters ::= BRACKET_OPEN [var_declaration (SEMICOLON var_declaration)*] BRACKET_CLOSE {
    methods = [variables="var_declaration"]
}*/
lambda_expr ::= BRACE_OPEN parameters? expressions? BRACE_CLOSE

private invoke_function_group ::= BINARY_FUNCTION | COMPLEX_FUNCTION | UNARY_FUNCTION | console_handler | prefix_expr

fake invoke_object ::= operator_type? invoke_function_group?
invoke_operator ::= operator_type {extends=invoke_object}
invoke_function ::= invoke_function_group {extends=invoke_object}

invoke_operation ::= (iterator_type | operator_type)+

fake invoke_expr ::= (invoke_operator | invoke_function) arguments_list? invoke_operation? expression?
prefix_invoke_expr ::= invoke_operator arguments_list invoke_operation? expression? { pin=2 extends=invoke_expr}
function_invoke_expr ::= invoke_function ((arguments_list? invoke_operation? expression) | (arguments_list invoke_operation?)) { extends=invoke_expr }

private invoke_group ::= prefix_invoke_expr | function_invoke_expr

projection_expr ::= PAREN_OPEN invoke_function invoke_operation PAREN_CLOSE

type_cast_expr ::= TYPE_CAST_PATTERN expression? {pin = 1 methods=[typeCast="TYPE_CAST_PATTERN"]}

// extends doesn't work in this case - have to do implements and redefine the method for each
table_column ::= (var_declaration column_assignment_type expression) | expression {pin(".*")=2}
private table_columns_group ::= table_column (SEMICOLON table_column)* {pin(".*")="SEMICOLON"}
fake table_columns ::= table_columns_group {methods=[columns="table_column"]}
table_keys ::= table_columns_group {implements=table_columns methods=[columns="table_column"]}
table_values ::= table_columns_group {implements=table_columns methods=[columns="table_column"]}
table_expr ::= PAREN_OPEN BRACKET_OPEN [table_keys] BRACKET_CLOSE [table_values] PAREN_CLOSE { pin=2 methods=[keys="table_keys" values="table_values"]}

// But extends works here with no issues
query_column ::= (var_declaration column_assignment_type expression) | expression {pin(".*")=2}
private query_columns_group ::= query_column (QUERY_SPLITTER query_column)* {pin(".*")="QUERY_SPLITTER"}
fake query_columns ::= query_columns_group {methods=[columns="query_column"]}
query_keys ::= query_columns_group {extends=query_columns}
query_values ::= query_columns_group {extends=query_columns}
query_expr ::= QUERY_TYPE [query_values] (QUERY_BY query_keys)? QUERY_FROM expression {pin=1 methods=[QUERY_TYPE="QUERY_TYPE" keys="query_keys" values="query_values"] }

grouping_expr ::= BRACKET_OPEN expressions BRACKET_CLOSE

k_syntax_expr ::= invoke_operation+ expression

whatever_expr ::= (operator_type | iterator_type | OPERATOR_ARITHMETIC | SYMBOL_PATH_PATTERN | COLON | OPERATOR_COMMA | literal_expr)+ | system_function | FUNCTION_IMPORT

// Only these expressions can be used as a left arguments of invokes
prefix_expr ::=
    table_expr
    | vector_expr
    | parentheses_expr
    | literal_expr
    | lambda_expr
    | control_expr
    | condition_expr
    | projection_expr
    | grouping_expr
    | var_reference
    { elementType=expression}

expression ::= assignment_expr
    | type_cast_expr
    | query_expr
    | import_expr
    | invoke_group
    | prefix_expr
    | return_expr
    | signal_expr
    | k_syntax_expr
    | whatever_expr
    { extraRoot=true }